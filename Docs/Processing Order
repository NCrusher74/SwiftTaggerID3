
Reading:

1) `Mp3File` is initialized with the URL of a file and its `read` function passes the data on to `Tag`
2) `Tag` reads the data from the file and calls `TagValidator` to confirm that the file is valid and has valid tag data. If not, it throws an error
(`Tag` then begins to use `extract`/`dropFirst(_:)` methods to pull out pieces of the file data and handle them.)
4) `Tag` calls `TagProperties` to extract the tag `size` and `version` data
5) `Tag` extracts the identifier string and passes the data off to `Frame`
6) `Frame` uses the identifier string to decide which layout the data should be passed on to.
6a) If the identifier string is not contained within `KnownFrameLayoutIdentifier` the frame gets passed off to `UnknownFrame` which will pass-through the frame data unchanged.
6b) If the identifier string is one of the specialized frames, the data gets passed off to the appropriate frame type. Otherwise, it gets passed off to `StringFrame`
7) The frame types parse the data in conformance with the `FrameProtocol` requirements and...???

Question: Where does the [frameKey: frame] part of the `Tag` initializer come into this? `FrameKey` is a convenience thing to enable writing multiple versions of the same `Frame` where allowed. It doesn't really have anything to do with reading a frame?

Writing:
1) User selects a `FrameKey`, which assigns a specific kind of `Frame` and requires the user to satisfy its particular parameters. When the tag is built, each `FrameKey` must be unique, but the uniqueness may be determined by factors such a `language` or `description` parameters, rather than `layout`.
2) Something (`FrameProtocol?`) adds header data to the frame and passes it to `Tag`
3) `Tag` compiles the `[FrameKey: Frame]` dictionary into an array and adds appropriate header data.
3a) Any passed-through `unknown` tags, and any non-empty existing tags which haven't been edited, get added to the `[FrameKey: Frame]` dictionary as-is.
4) The tag is written when `Mp3File.write` is called.
